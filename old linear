///implementation for f32
    impl<const N: usize, const M: usize> LinearAlgebra for Matrix<f32, N, M> {
        type Scalar = f32;
        type AddOutput = Self;
        type MultIn<const P: usize> = Matrix<f32, M, P>;
        type MultOutput<const P: usize> = Matrix<f32, N, P>;
        type Square = Matrix<f32, N, N>;

        fn scale(&self, rhs: Self::Scalar) -> Self {
            let mut result = Self::default();
            for i in 0..N {
                for j in 0..M {
                    result.inner[i][j] = rhs * self[i][j];
                }
            }

            result
        }

        fn addition(&self, rhs: Self) -> Self {
            let mut result = Self::default();
            for (i, (row1, row2)) in self.inner.into_iter().zip(rhs.inner).enumerate() {
                for (j, (val1, val2)) in row1.into_iter().zip(row2).enumerate() {
                    result.inner[i][j] = val1 + val2;
                }
            }
            result
        }

        fn multiply<const P: usize>(&self, rhs: Matrix<f32, M, P>) -> Matrix<f32, N, P> {
            let mut result = Matrix::default();
            for i in 0..N {
                for j in 0..P {
                    for k in 0..M {
                        result.inner[i][j] += self[i][k] * rhs[k][j];
                    }
                }
            }

            result
        }

        fn get_det(&self) -> f64 {
            if N != M {
                return 0.0;
            }
            if N == 0 {
                return 0.0;
            }
            if N == 1 {
                return self[0][0] as f64;
            }
            if N == 2 {
                (self[0][0] * self[1][1] - self[1][0] * self[0][1]) as f64
            } else {
                let (p, _, u) = self.get_plu_decomposition().unwrap();

                //p determinant

                let mut permutation_nb: u8 = 0;
                for i in 0..N {
                    if p[i][i] != 1.0 {
                        permutation_nb += 1;
                    }
                    permutation_nb %= 4;
                }
                permutation_nb /= 2;
                let p_det = if permutation_nb == 0 { 1. } else { -1. };

                //u determinant
                let mut u_det: f64 = 1.0;
                for i in 0..N {
                    u_det *= u[i][i] as f64;
                }

                p_det * u_det /* * l_det (l_det is equal to 1)*/
            }
        }

        fn get_reduce_row_echelon(&self) -> Self {
            let mut result = *self;

            let mut lead = 0;

            for r in 0..N {
                if lead >= N {
                    return result;
                }

                let mut i = r;
                while result[i][lead] == 0.0 {
                    i += 1;
                    if i == N {
                        i = r;
                        lead += 1;
                        if lead >= M {
                            return result;
                        }
                    }
                }
                result.permute_row(i, r);

                //Normalization of the leading row
                let mut lead_value = result[r][lead];
                for j in 0..M {
                    result[r][j] /= lead_value;
                }

                //Elimination of column entries
                for i in 0..N {
                    if i != r {
                        lead_value = result[i][lead];
                        for j in 0..M {
                            result[i][j] -= lead_value * result[r][j];
                        }
                    }
                }
                lead += 1;
            }

            result
        }

        fn get_plu_decomposition(&self) -> Option<(Self::Square, Self::Square, Self::Square)> {
            let self_square = match self.squared_or_none() {
                Some(m) => m,
                None => {
                    return None;
                }
            };

            let mut p = Matrix::identity();
            let mut l = Matrix::zero();
            let mut u = self_square;

            for k in 0..N {
                //finding th pivot
                let mut pivot_index = k;
                let mut pivot_value = u[k][k].abs();
                for i in (k + 1)..N {
                    if u[i][k].abs() > pivot_value {
                        pivot_value = u[i][k].abs();
                        pivot_index = i;
                    }
                }

                //row swaping
                if pivot_index != k {
                    u.permute_row(k, pivot_index);
                    p.permute_row(k, pivot_index);
                    if k > 0 {
                        /*
                        l.permute_row(k, pivot_index);
                        */
                        for j in 0..k {
                            let tmp = l[k][j];
                            l[k][j] = l[pivot_index][j];
                            l[pivot_index][j] = tmp;
                        }
                    }
                }

                //entries elimination below the pivot
                for i in (k + 1)..N {
                    l[i][k] = u[i][k] / u[k][k];
                    for j in k..N {
                        u[i][j] -= l[i][k] * u[k][j];
                    }
                }
            }

            for i in 0..N {
                l[i][i] = 1.0;
            }

            Some((p, l, u))
        }

        fn get_inverse(&self) -> Option<Self>
        where
            Self: Sized,
        {
            // Check if the matrix is square
            if N == M {
                // Special case for 1x1 matrix
                if N == 1 {
                    if self[0][0] == 0.0 {
                        None
                    } else {
                        Some(
                            Self::try_into_matrix(Matrix::from([[1.0 / self[0][0]]])).unwrap(),
                        )
                    }
                // Special case for 2x2 matrix
                } else if N == 2 {
                    let det = self.get_det();
                    if det != 0.0 {
                        // Return the inverse of 2x2 matrix using the formula
                        return Some(
                            (1.0 / det) as f32
                                * Self::try_into_matrix(Matrix::from([
                                    [self[1][1], -self[0][1]],
                                    [-self[1][0], self[0][0]],
                                ]))
                                .unwrap(),
                        );
                    } else {
                        None
                    }
                } else {
                    //Gaussian elimination
                    let mut m_self = *self; 
                    let mut result = Self::identity();

                    let mut lead = 0;

                    //is the matrice singulare
                    for r in 0..N {
                        if lead >= N {
                            return None; 
                        }

                        let mut i = r;
                        while m_self[i][lead] == 0.0 {
                            i += 1;
                            //is the matrice singulare
                            if i == N {
                                return None; 
                            }
                        }

                        m_self.permute_row(i, r);
                        result.permute_row(i, r);

                        // normalize the leading row
                        let lead_value = m_self[r][lead];
                        for j in 0..M {
                            m_self[r][j] /= lead_value;
                            result[r][j] /= lead_value;
                        }

                        // Elimination of all other entries in the column
                        for i in 0..N {
                            if i != r {
                                let lead_value = m_self[i][lead];
                                for j in 0..M {
                                    m_self[i][j] -= lead_value * m_self[r][j];
                                    result[i][j] -= lead_value * result[r][j];
                                }
                            }
                        }
                        lead += 1;
                    }

                    // Return the inverse matrix
                    return Some(result);
                }
            } else {
                None
            }
        }

        fn zero() -> Self {
            let mut result = Self::default();
            for i in 0..N {
                for j in 0..M {
                    result.inner[i][j] = 0.0;
                }
            }
            result
        }

        fn identity() -> Self {
            let mut result = Self::default();
            for i in 0..N {
                for j in 0..M {
                    if i == j {
                        result.inner[i][j] = 1.0;
                    } else {
                        result.inner[i][j] = 0.0;
                    }
                }
            }
            result
        }

        fn permutation(l1: usize, l2: usize) -> Self {
            let mut result = Self::default();
            let mut col_index;
            for i in 0..N {
                if i == l1 {
                    col_index = l2;
                } else if i == l2 {
                    col_index = l1;
                } else {
                    col_index = i
                }
                for j in 0..M {
                    if j == col_index {
                        result.inner[i][j] = 1.0;
                    } else {
                        result.inner[i][j] = 0.0;
                    }
                }
            }
            result
        }

        fn inflation(i: usize, value: f32) -> Self {
            let mut result = Self::default();
            for row_index in 0..N {
                for column_inndex in 0..M {
                    if row_index == column_inndex {
                        if row_index == i {
                            result.inner[row_index][column_inndex] = value;
                        } else {
                            result.inner[row_index][column_inndex] = 1.0;
                        }
                    } else {
                        result.inner[row_index][column_inndex] = 0.0;
                    }
                }
            }
            result
        }

        fn is_upper_triangular(&self) -> bool {
            for i in 0..N {
                if i < M {
                    for j in 0..i {
                        if self[i][j] != 0.0 {
                            return false;
                        }
                    }
                }
            }

            true
        }

        fn is_lower_triangular(&self) -> bool {
            for i in 0..N {
                for j in (i + 1)..M {
                    if self[i][j] != 0.0 {
                        return false;
                    }
                }
            }
            true
        }
    }
